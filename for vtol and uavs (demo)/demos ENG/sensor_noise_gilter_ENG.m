%% ========================================================================
%  PROJECT: UAV Sensor Noise Filtering Simulation (Discrete Low-Pass Filter)
%  AUTHOR: Serdar Sokmen
%  PLATFORM: MATLAB 
%
%  ------------------------------------------------------------------------
%  DESCRIPTION & AVIONICS CONTEXT:
%  ------------------------------------------------------------------------
%  In Unmanned Aerial Vehicles (UAVs), specifically Quadplanes and VTOLs,
%  Raw Sensor Data (IMU - Accelerometer/Gyroscope) is heavily corrupted by
%  mechanical vibrations generated by BLDC motors and propellers.
%
%  Feeding this raw, noisy data directly into a PID Flight Controller causes:
%  1. Overheating motors (due to rapid twitching).
%  2. Poor flight stability and oscillations.
%  3. Inaccurate attitude estimation (AHRS).
%
%  OBJECTIVE:
%  This script simulates a noisy pitch-angle sensor reading and implements
%  a "First-Order Discrete Low-Pass Filter" (Infinite Impulse Response - IIR)
%  to recover the estimated true attitude.
%
%  MATHEMATICAL MODEL (Difference Equation):
%  y[n] = alpha * x[n] + (1 - alpha) * y[n-1]
%
%  Variables:
%  x[n]   : Current raw measurement (Noisy Input)
%  y[n-1] : Previous filtered estimate (Memory)
%  alpha  : Smoothing factor (0 < alpha < 1) -> Tunable Parameter
%
%  Key Trade-off:
%  - Low Alpha  -> Very smooth signal, but HIGH LATENCY (Lag).
%  - High Alpha -> Low latency, but NOISY signal.
% =========================================================================

clc; clear; close all;

%% 1. SIMULATION SETUP (Simülasyon Ayarları)
% -------------------------------------------------------------------------
duration = 10;          % Total simulation time in seconds
sampling_rate = 100;    % Hz (Standard Loop Rate for Pixhawk/Ardupilot)
dt = 1/sampling_rate;   % Time step (0.01s)
t = 0:dt:duration;      % Time vector

%% 2. SIGNAL GENERATION (Sinyal Oluşturma)
% -------------------------------------------------------------------------
% SCENARIO: 
% The UAV is performing a gentle "Pitch Up" and "Pitch Down" maneuver.
% Frequency = 0.5 Hz means one full up/down motion takes 2 seconds.
freq = 0.5; 
amplitude = 10; % Degrees (Drone pitches 10 degrees up and down)

% Ideal (Truth) Signal - What the drone is actually doing physics-wise
true_signal = amplitude * sin(2 * pi * freq * t); 

% NOISE GENERATION (Gürültü Ekleme):
% We simulate high-frequency vibrations typical of unbalanced props.
% 'randn' generates Gaussian white noise.
noise_intensity = 4.0; % High vibration level (4 degrees of jitter)
noise = noise_intensity * randn(size(t)); 

% RAW SENSOR DATA:
% This is what the flight controller actually "sees" from the MEMS sensor.
sensor_reading = true_signal + noise;

%% 3. FILTER IMPLEMENTATION (Filtre Algoritması)
% -------------------------------------------------------------------------
% TUNING PARAMETER: ALPHA
% This is the most critical value in avionics filter design.
% alpha = dt / (RC + dt) in analog terms.
%
% Try changing this value to see the effect:
% 0.05 -> Extremely smooth, huge lag (Bad for racing drones)
% 0.15 -> Balanced (Good for cinematic/camera drones)
% 0.80 -> Very responsive, noisy (Good for small racers)
alpha = 0.10; 

% Pre-allocate array for speed (Best coding practice in MATLAB)
filtered_signal = zeros(size(t));

% Initial Condition: Assume drone starts at the first sensor reading
filtered_signal(1) = sensor_reading(1); 

% THE LOOP (Simulating Real-Time Processing)
for n = 2:length(t)
    % ---------------------------------------------------------------------
    % ALGORITHM EXPLANATION:
    % We take a small portion (alpha) of the NEW noisy measurement,
    % and mix it with a large portion (1-alpha) of the PREVIOUS estimate.
    % This "inertia" resists sudden changes (noise) but allows slow changes.
    % ---------------------------------------------------------------------
    
    current_measurement = sensor_reading(n);
    previous_estimate   = filtered_signal(n-1);
    
    % The Low-Pass Filter Formula
    filtered_signal(n) = (alpha * current_measurement) + ...
                         ((1 - alpha) * previous_estimate);
end

%% 4. PERFORMANCE ANALYSIS & VISUALIZATION (Analiz)
% -------------------------------------------------------------------------
figure('Name', 'Avionics Filter Analysis', 'Color', 'w');

% Subplot 1: Time Domain Comparison
subplot(2,1,1);
    plot(t, sensor_reading, 'Color', [0.8, 0.8, 0.8], 'LineWidth', 0.5); hold on;
    plot(t, true_signal, 'g--', 'LineWidth', 2);
    plot(t, filtered_signal, 'r-', 'LineWidth', 2);
    
    title(sprintf('Low-Pass Filter Performance (Alpha = %.2f)', alpha), 'FontSize', 12);
    xlabel('Time (seconds)');
    ylabel('Pitch Angle (degrees)');
    legend('Raw Noisy Sensor', 'Ground Truth (Ideal)', 'Filtered Output', 'Location', 'best');
    grid on;
    xlim([0 4]); % Zoom in on the first 4 seconds for clarity

% Subplot 2: Lag/Latency Analysis
% In control theory, "Phase Lag" is critical. If lag is too high, 
% the PID controller will react too late, causing instability.
subplot(2,1,2);
    lag_error = true_signal - filtered_signal;
    plot(t, lag_error, 'b', 'LineWidth', 1.5);
    yline(0, 'k--');
    
    title('Filter Latency (Error between Truth and Filtered)', 'FontSize', 12);
    xlabel('Time (seconds)');
    ylabel('Error (degrees)');
    legend('Tracking Error / Lag');
    grid on;
    xlim([0 4]);

% Console Output
fprintf('------------------------------------------------\n');
fprintf('SIMULATION RESULTS:\n');
fprintf('------------------------------------------------\n');
fprintf('Sampling Rate : %d Hz\n', sampling_rate);
fprintf('Filter Alpha  : %.2f\n', alpha);
fprintf('Max Noise     : +/- %.1f degrees\n', max(abs(noise)));
fprintf('Max Lag Error : %.2f degrees (Check if acceptable for flight)\n', max(abs(lag_error)));
fprintf('------------------------------------------------\n');